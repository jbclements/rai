RAI - Racket Abstract Interpretation


Entry: Move to git / github / racket package
Date: Sun Jun  2 19:13:02 EDT 2013

Starting on a fresh repo.

http://zwizwa.be/rai

raco pkg install github://github.com/zwizwa/rai/master



Entry: TODO
Date: Sun Jun  2 19:14:08 EDT 2013


Maybe good to make a list of the small things that need to be done.

- FIXES:

  - ai-stream.rkt   (write in terms of ai-array.rkt output?)

  - delay line allocation: phase 1 -> phase 2.

  - make time block explicit (subsampling) and fixed size

  - proper feedback operator

  - compute transfer function as ratfunc.


- FEATURES:

  - constant arrays.

  - presets

  - state initialization

  - generate GUI from description

  - loop fusion?




Entry: Add a `where' form?
Date: Sun Jun  2 19:27:46 EDT 2013

This would allow specification of inputs/outputs in a more
straightforward way, such that output arity is visible at the syntax
level.

E.g.

(proc (in ...)
      (out ...)
  (where
     ((a ...)
      (b ...)
      ...)))



Entry: Run generated C code from Scheme
Date: Mon Jun  3 19:48:43 EDT 2013

3 ways to run code in Scheme:

- provide separate interpretation, like ai-stream.rkt (reference implementation)
- compile the pre-C imperative intermediate language to Scheme
- load a compiled C module




Entry: John Clements Course
Date: Mon Jun 10 07:57:55 EDT 2013


http://www.brinckerhoff.org/JBCsite/index.html
http://www.brinckerhoff.org/clements/
http://www.brinckerhoff.org/clements/csc123-fa12/index.html




Entry: Next
Date: Mon Jun 10 08:08:37 EDT 2013

Low on time and energy.  What needs to happen next?


- LLVM C/C++ bindings

- Load C code in Scheme

- Scheme semantics based on ai-array form output



Entry: KVR post
Date: Tue Jun 11 08:43:08 EDT 2013

http://www.kvraudio.com/forum/viewtopic.php?p=5385673#5385673

Hi Frank,

What I find most interesting in language design is the basic
principles or "axioms", being
1) primitive operations, and
2) composition/abstraction mechanisms to build new operations

IIUC, your patch language is functional, except for the primitives,
which have state.  Some questions about the composition mechanism:

- How do you differentiate between "class" and "instance" for the
  primitives?  I.e. there is Osc1 and Osc2.  Are these fixed
  instances of a shared oscillator class?

- Is there an abstraction mechanism?  I.e. is there a way to take a
  couple of modules and create a new black box to be used in another
  patch?

Cheers
Tom





