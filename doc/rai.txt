RAI - Racket Abstract Interpretation

Development log for the RAI project.

The goal of this project is to explore code generation and validation
using techniques based on Abstract Interpretation, implemented in
Racket.

For more information, visit http://zwizwa.be/rai

This log was forked from:
http://zwizwa.be/-/meta
which contains more information about the Haskell leg of the project.


Entry: Move to git / github / racket package
Date: Sun Jun  2 19:13:02 EDT 2013

Starting on a fresh repo.

http://zwizwa.be/rai

raco pkg install github://github.com/zwizwa/rai/master

parent dev log:     http://zwizwa.be/-/meta
parent darcs repo:  http://zwizwa.be/darcs/meta


Entry: TODO
Date: Sun Jun  2 19:14:08 EDT 2013


Maybe good to make a list of the small things that need to be done.

- FIXES:

  - ai-stream.rkt   (write in terms of ai-array.rkt output?)

  - delay line allocation: phase 1 -> phase 2.

  - make time block explicit (subsampling) and fixed size

  - proper feedback operator

  - compute transfer function as ratfunc.


- FEATURES:

  - constant arrays.

  - presets

  - state initialization

  - generate GUI from description

  - loop fusion?




Entry: Add a `where' form?
Date: Sun Jun  2 19:27:46 EDT 2013

This would allow specification of inputs/outputs in a more
straightforward way, such that output arity is visible at the syntax
level.

E.g.

(proc (in ...)
      (out ...)
  (where
     ((a ...)
      (b ...)
      ...)))



Entry: Run generated C code from Scheme
Date: Mon Jun  3 19:48:43 EDT 2013

3 ways to run code in Scheme:

- provide separate interpretation, like ai-stream.rkt (reference implementation)
- compile the pre-C imperative intermediate language to Scheme
- load a compiled C module




Entry: John Clements Course
Date: Mon Jun 10 07:57:55 EDT 2013


http://www.brinckerhoff.org/JBCsite/index.html
http://www.brinckerhoff.org/clements/
http://www.brinckerhoff.org/clements/csc123-fa12/index.html




Entry: Next
Date: Mon Jun 10 08:08:37 EDT 2013

Low on time and energy.  What needs to happen next?


- LLVM C/C++ bindings

- Load C code in Scheme

- Scheme semantics based on ai-array form output



Entry: KVR post
Date: Tue Jun 11 08:43:08 EDT 2013

http://www.kvraudio.com/forum/viewtopic.php?p=5385673#5385673

Hi Frank,

What I find most interesting in language design is the basic
principles or "axioms", being
1) primitive operations, and
2) composition/abstraction mechanisms to build new operations

IIUC, your patch language is functional, except for the primitives,
which have state.  Some questions about the composition mechanism:

- How do you differentiate between "class" and "instance" for the
  primitives?  I.e. there is Osc1 and Osc2.  Are these fixed
  instances of a shared oscillator class?

- Is there an abstraction mechanism?  I.e. is there a way to take a
  couple of modules and create a new black box to be used in another
  patch?

Cheers
Tom


Entry: Pd-dev, music-dsp, racket list post
Date: Wed Jun 12 11:28:54 EDT 2013



Hi List,

I've been cleaning it up a bit. Still quite raw in the details, but it basically works.

added synth-lib.rkt basic synth kit and synth.rkt example synthesizer:

- envelopes
- parameter control dezippers
- parameter control scales (exponential, "squashed" exponential, ...)
- SVF filter
- supersaw osc
- anti-aliased saw osc
- saturation functions
- FDN reverb tail

How I use it at this time, Linux + Pd:

make sp_host.pd_linux # build binary Pd wrapper
pd sp_test.pd & # run Pd patch built around sp_host
make livecode # continuously compile synth.rkt -> synth.sp binary module

then edit synth.rkt or any of its dependencies and the binary code running in Pd will be updated, leaving state intact if the type didn't change.

some docs at http://zwizwa.be/rai


For headless Windows VST plugin:  "make synth.dll"
This needs a Linux->Windows cross compiler; follow the error messages.

Cheers
Tom



Entry: LLVM?
Date: Wed Jun 12 13:28:34 EDT 2013

Maybe an LLVM target would be a nice addition.  Running code in-image
without external C compiler dependencies is attractive, though is it
worth the trouble?



Entry: Industry integration: validated, bottom-up design
Date: Wed Jun 12 13:46:55 EDT 2013

I'd like to be able to integrate what I've learned up to now (the
knowledge that lead to RAI) and steer it more into a direction that is
usable in an industrial setting.

At this point it is usable for designing music DSP software on PCs or
mobile devices, but not yet so usable for machine mapping as would be
encountered in a typical embedded development settings, i.e. the
projects that pay the bills.

One important element is target dependency.  It might make more sense
to construct a tool that helps manual machine mapping of an existing
algorithm, than to attempt to work top-down as I'm doing for the synth
work.

At least for code running on a quirky DSP chip there is going to be a
significant amount of squeezing involved to map to a particular
target.  It doesn't seem that the trend of quirky hardware is not
going to change much in the near future, as power consumption and
device cost constraints will keep much of the manual design approach
alive.

For the big guys, there are plenty of expensive tools available.  Have
a look at the MathWorks product range.  More, bigger tools can be
found in the ASIC industry.  For the small guys doing one-off jobs,
these tools just too expensive.  What I've been wondering for 10 years
is how far can one get with open tools to make the lone wolf embedded
developer more productive?

I want to stress this: none of the ideas here are new.
What is new is to keep it simple, small and malleable.

A large constraint in reality is the introduction of exotic tool
chains.  My conclusion is that people hate it: it's too big a risk to
use yet another quirky code generator whenever a new person joins the
team.  A big constraint for designing tools is to make sure they can
get out of the way, i.e. that you can switch them OFF and drop down to
writing straight ASM or C code.

In a nutshell: VALIDATION of a low-level implementation is more
important than GENERATION from high to low level.

In practice, in the RAI framework, this would boil down to finding a
set of primitives, probably based on the machine's primitive, AND a
set of machine constraints and resource management annotations.

This is not a simple problem.  To keep it simple, a most
straightforward approach is to start with a reduced assembler
language, and see how to put a functional semantics on top of that.


So what about this for future direction:

  - Aiming at validation, use the abstract interpretation trick to
    approximate the semantics of a real device.

  - Pick a target to test this: dsPIC or ARM DSP / Cortex M4



Entry: What target to pick?
Date: Wed Jun 12 13:57:31 EDT 2013

dsPIC:

+ combined with PIC18 support in Staapl, I could aim at 1 vendor
  (Microchip) / 1 tool (Racket) approach.

+ DIP available, good for grassroots electronics projects

- typical quirky DSP arch with lots of constraints

- no free optimizing C compiler for both PIC18 and dsPIC.



ARM Cortex M4 [1]

+ industry standard, multiple vendors: TI Stellaris, STM32 F3,F4

+ good open tooling support

+ plenty of boards

- no DIP available



[1] http://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M4



Entry: Idiomatic C
Date: Wed Jun 12 14:50:53 EDT 2013

It would be interesting to find the subset of C that can accomodate
the basic stream language's semantics.



