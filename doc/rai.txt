RAI - Racket Abstract Interpretation

Development log for the RAI project.

The goal of this project is to explore code generation and validation
using techniques based on Abstract Interpretation, implemented in
Racket.

For more information, visit http://zwizwa.be/rai

This log was forked from:
http://zwizwa.be/-/meta
which contains more information about the Haskell leg of the project.


Entry: Move to git / github / racket package
Date: Sun Jun  2 19:13:02 EDT 2013

Starting on a fresh repo.

http://zwizwa.be/rai

raco pkg install github://github.com/zwizwa/rai/master

parent dev log:     http://zwizwa.be/-/meta
parent darcs repo:  http://zwizwa.be/darcs/meta


Entry: TODO
Date: Sun Jun  2 19:14:08 EDT 2013


Maybe good to make a list of the small things that need to be done.

- FIXES:

  - ai-stream.rkt   (write in terms of ai-array.rkt output?)

  - delay line allocation: phase 1 -> phase 2.

  - make time block explicit (subsampling) and fixed size

  - proper feedback operator

  - compute transfer function as ratfunc.


- FEATURES:

  - constant arrays.

  - presets

  - state initialization

  - generate GUI from description

  - loop fusion? (check out Feldspar)




Entry: Add a `where' form?
Date: Sun Jun  2 19:27:46 EDT 2013

This would allow specification of inputs/outputs in a more
straightforward way, such that output arity is visible at the syntax
level.

E.g.

(proc (in ...)
      (out ...)
  (where
     ((a ...)
      (b ...)
      ...)))



Entry: Run generated C code from Scheme
Date: Mon Jun  3 19:48:43 EDT 2013

3 ways to run code in Scheme:

- provide separate interpretation, like ai-stream.rkt (reference implementation)
- compile the pre-C imperative intermediate language to Scheme
- load a compiled C module




Entry: John Clements Course
Date: Mon Jun 10 07:57:55 EDT 2013


http://www.brinckerhoff.org/JBCsite/index.html
http://www.brinckerhoff.org/clements/
http://www.brinckerhoff.org/clements/csc123-fa12/index.html




Entry: Next
Date: Mon Jun 10 08:08:37 EDT 2013

Low on time and energy.  What needs to happen next?


- LLVM C/C++ bindings

- Load C code in Scheme

- Scheme semantics based on ai-array form output



Entry: KVR post
Date: Tue Jun 11 08:43:08 EDT 2013

http://www.kvraudio.com/forum/viewtopic.php?p=5385673#5385673

Hi Frank,

What I find most interesting in language design is the basic
principles or "axioms", being
1) primitive operations, and
2) composition/abstraction mechanisms to build new operations

IIUC, your patch language is functional, except for the primitives,
which have state.  Some questions about the composition mechanism:

- How do you differentiate between "class" and "instance" for the
  primitives?  I.e. there is Osc1 and Osc2.  Are these fixed
  instances of a shared oscillator class?

- Is there an abstraction mechanism?  I.e. is there a way to take a
  couple of modules and create a new black box to be used in another
  patch?

Cheers
Tom


Entry: Pd-dev, music-dsp, racket list post
Date: Wed Jun 12 11:28:54 EDT 2013



Hi List,

I've been cleaning it up a bit. Still quite raw in the details, but it basically works.

added synth-lib.rkt basic synth kit and synth.rkt example synthesizer:

- envelopes
- parameter control dezippers
- parameter control scales (exponential, "squashed" exponential, ...)
- SVF filter
- supersaw osc
- anti-aliased saw osc
- saturation functions
- FDN reverb tail

How I use it at this time, Linux + Pd:

make sp_host.pd_linux # build binary Pd wrapper
pd sp_test.pd & # run Pd patch built around sp_host
make livecode # continuously compile synth.rkt -> synth.sp binary module

then edit synth.rkt or any of its dependencies and the binary code running in Pd will be updated, leaving state intact if the type didn't change.

some docs at http://zwizwa.be/rai


For headless Windows VST plugin:  "make synth.dll"
This needs a Linux->Windows cross compiler; follow the error messages.

Cheers
Tom



Entry: LLVM?
Date: Wed Jun 12 13:28:34 EDT 2013

Maybe an LLVM target would be a nice addition.  Running code in-image
without external C compiler dependencies is attractive, though is it
worth the trouble?



Entry: Industry integration: validated, bottom-up design
Date: Wed Jun 12 13:46:55 EDT 2013

I'd like to be able to integrate what I've learned up to now (the
knowledge that lead to RAI) and steer it more into a direction that is
usable in an industrial setting.

At this point it is usable for designing music DSP software on PCs or
mobile devices, but not yet so usable for machine mapping as would be
encountered in a typical embedded development settings, i.e. the
projects that pay the bills.

One important element is target dependency.  It might make more sense
to construct a tool that helps manual machine mapping of an existing
algorithm, than to attempt to work top-down as I'm doing for the synth
work.

At least for code running on a quirky DSP chip there is going to be a
significant amount of squeezing involved to map to a particular
target.  It doesn't seem that the trend of quirky hardware is not
going to change much in the near future, as power consumption and
device cost constraints will keep much of the manual design approach
alive.

For the big guys, there are plenty of expensive tools available.  Have
a look at the MathWorks product range.  More, bigger tools can be
found in the ASIC industry.  For the small guys doing one-off jobs,
these tools just too expensive.  What I've been wondering for 10 years
is how far can one get with open tools to make the lone wolf embedded
developer more productive?

I want to stress this: none of the ideas here are new.
What is new is to keep it simple, small and malleable.

A large constraint in reality is the introduction of exotic tool
chains.  My conclusion is that people hate it: it's too big a risk to
use yet another quirky code generator whenever a new person joins the
team.  A big constraint for designing tools is to make sure they can
get out of the way, i.e. that you can switch them OFF and drop down to
writing straight ASM or C code.

In a nutshell: VALIDATION of a low-level implementation is more
important than GENERATION from high to low level.

In practice, in the RAI framework, this would boil down to finding a
set of primitives, probably based on the machine's primitive, AND a
set of machine constraints and resource management annotations.

This is not a simple problem.  To keep it simple, a most
straightforward approach is to start with a reduced assembler
language, and see how to put a functional semantics on top of that.


So what about this for future direction:

  - Aiming at validation, use the abstract interpretation trick to
    approximate the semantics of a real device.

  - Pick a target to test this: dsPIC or ARM DSP / Cortex M4



Entry: What target to pick?
Date: Wed Jun 12 13:57:31 EDT 2013

dsPIC:

+ combined with PIC18 support in Staapl, I could aim at 1 vendor
  (Microchip) / 1 tool (Racket) approach.

+ DIP available, good for grassroots electronics projects

- typical quirky DSP arch with lots of constraints

- no free optimizing C compiler for both PIC18 and dsPIC.



ARM Cortex M4 [1]

+ industry standard, multiple vendors: TI Stellaris, STM32 F3,F4

+ good open tooling support

+ plenty of boards

- no DIP available



[1] http://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M4



Entry: Idiomatic C
Date: Wed Jun 12 14:50:53 EDT 2013

It would be interesting to find the subset of C that can accomodate
the basic stream language's semantics.



Entry: Merging ideas: Staapl and RAI
Date: Wed Jun 12 16:53:54 EDT 2013

Both have an element of bottom-up design, but for RAI, the bottom is a
small, well-defined language, while for Staapl, bottom is the machine
language.

Making this work for Staapl was one of the goals, but has not been
reached yet.

I wonder where the middle ground is here: design a machine abstraction
close enough to the real machine to allow for hand-tuned allocation,
and high level enough to have a decent semantics.

Another thing is to properly gauge the importance of resource
efficiency vs. safety/correctness.  If resource efficiency is not a
main driver, code gen might be a better option.



Entry: Project management: future of RAI
Date: Thu Jun 13 09:53:11 EDT 2013

After about 5 months the goals are reached.  RAI is good enough for
its initial intended purpose.  The rest seems to be "long tail"
maintenance, refinement, cleanup and gaining more insight through
concrete use cases.

I find myself in a bit of an impasse at this point, as the strongly
mobilizing curiosity is no longer there.

Maybe it is important at this point to realize that, and keep what
there is now as a stable core.  I.e. build extensions as external
projects.




Entry: A simplified simulator
Date: Thu Jun 13 14:36:57 EDT 2013

Problem: find a good approximation to a chip's instruction set that
can be embedded in a functional language.

This attempts to connect two worlds:
  - Easy translation to "real" device semantics
  - Easy translation from pure functional constructs

The problem here is resource management.

For the particular problem of simplifying the dsPIC, this would be to
abstract X/Y data memory, accumulator and addressing modes.






Entry: Composing state machines
Date: Fri Jun 14 10:06:26 EDT 2013


Note these are synchronous state machines, which are a bit simpler
than event-based ones.  The basic model I use for the audio DSP work
is the state space model (SSM) or state space representation, which
has nice properties if it is linear:

http://en.wikipedia.org/wiki/State_space_representation

Goal: represent a stream operator in Haskell in an abstract way, but
allow for C code generation from the description.

A stream operator consists of an initial state value and update
function with types:

s
(s,i) -> (s,o)

Ignoring the explicit state, the straightforward way to represent a
stream operator as a pure function is something like this:

    data S a = S a (S a)
    S i -> S o

However, the state info is lost here.  So the SSM rep can be mapped to
the stream rep, but not vice versa.


When composing two SSMs (ignoring the initial state) you get something
like:

   ( (s1,a) -> (s1,b) ) ->
   ( (s2,b) -> (s2,c) ) ->

   ((s1,s2),a) -> ((s1,s2), c)

This is troublesome, because the state "grows".

The whole thing is here:
http://zwizwa.be/darcs/meta/dspm/SSM.hs


The composition would fit neatly in the Arrow abstraction except for
that dangling state vector.

It is possible to use existential types to hide the states.
The trouble with that is they become quite inaccessible.

In the end, after composition, I really want a type (s,i) -> (s,o)
where s is a large composition of per-SSM state vectors, because that
information is used to generate C code.  I also want this to fit in
the Arrow abstraction, so it integrates better into Haskell.

For code generation, the SSM idea is combined with the "final tagless"
representation trick to perform abstract interpretation.  See:

http://zwizwa.be/darcs/meta/dspm/Control.hs
http://zwizwa.be/darcs/meta/dspm/Data.hs
http://zwizwa.be/darcs/meta/dspm/Struct.hs

All this +- works.  To work out how exactly to use the existential
types, I did some type directed programming to just see where the
types lead me, but in the end I got confused.  It all seems a bit
clumsy.

I took that idea and went back to Scheme (Racket) to do what I wanted
to do in the first place; to build a tool that I can use effectively
to write audio DSP code (*).  This is the result up to now:
http://zwizwa.be/rai/

Doing it in Scheme allowed me to "emulate" types and type classes.  An
interesting exercise in itself, but still, in Haskell it would be a
lot simpler.

Now that I know that the basic idea works, I'd like find a good way to
port it back to Haskell, probably on top of Feldspar.
http://hackage.haskell.org/package/feldspar-language




Entry: Fluxus / LLVM / Pd
Date: Mon Jun 17 10:53:31 EDT 2013

So, what's next?  A big fork in the road:

- Target "real" DSPs, i.e. TI C2000, MicroChip dsPIC, ...

- Integrate into host tools like Pd, Fluxus, ...

Former seems a bit far off at this point.  It would be great to have a
real project drive this.  Hybrid analog synth based on dsPIC?  
I ordered a C2000 eval board, which might lead to an interesting avenue.


For the latter, it would still be possible to use an external .c to
.so compilation step, but it is really awkward.  It might be a lot
better to bite the bullet and go for a JITtable LLVM approach.

The question is where to make the Scheme <-> C bridge for the LLVM
bindings.  As I understand, C++ isn't so easy from Racket FFI[1].




[1] https://groups.google.com/forum/?fromgroups#!topic/racket-users/GFrGBbczTc0



Entry: Fluxus install
Date: Mon Jun 17 11:11:12 EDT 2013

Probably best to just follow instructions and install to /usr/local

* Racket from git

git clone git://git.racket-lang.org/plt
cd plt
./configure --enable-shared --prefix=/usr/local
make
sudo make install


* Fluxus from git

git clone git://git.savannah.nongnu.org/fluxus.git
cd fluxus
scons

NOTE: I could not get this to work without symlinking bin & lib &
include from the git-racket tree into /usr/local



Entry: Live coding
Date: Mon Jun 17 16:49:40 EDT 2013

Back to the life coding idea.  I want to stick to the Scheme approach:
language works better than graphical programming, but I also want Bret
Victor's number boxes[1], essentially Pd's number boxes in code.

I wonder if this is possible in Fluxus.

[1] http://worrydream.com/#!/InventingOnPrinciple


Entry: Fluxus question
Date: Mon Jun 17 16:56:07 EDT 2013


fluxus@lists.pawfal.org


Hi List,

I recently saw Brent Victor's "Inventing On Principle"
http://worrydream.com/#!/InventingOnPrinciple

How hard would it be to make those "number sliders" work in Fluxus?
That is, if it's not already possible..

Basically, hover over a number in the editor and allow the mouse to change its range.

Cheers
Tom

